# Copyright (c) 2021, Cody Opel <cwopel@chlorm.net>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


use file
use path path_
use github.com/chlorm/elvish-stl/io
use github.com/chlorm/elvish-stl/path
use github.com/chlorm/elvish-stl/str


fn download {|file|
    var UCD-VERSION = '14.0.0'
    e:curl '-sL' 'https://www.unicode.org/Public/'$UCD-VERSION'/ucd/'$file
}

var MAX-CHAR-DEC = 159

fn hex-to-dec {|hex|
    base 10 '0x'$hex
}

fn ucd-control-dec {|line|
    var i = [ (str:split ';' $line) ]
    var group = $i[2]
    var hexadecimal = $i[0]

    if (==s $group 'Cc') {
        put $hexadecimal
    } else {
        put $nil
    }
}

fn ucd-find-ccs {
    var unicodedata = (path_:temp-file)
    download 'UnicodeData.txt' > $unicodedata
    var ucd = [ (str:to-nonempty-lines (io:open $unicodedata[name])) ]
    for i $ucd {
        var dec = (ucd-control-dec $i)
        if (eq $dec $nil) {
            continue
        }
        if (>= (hex-to-dec $dec) $MAX-CHAR-DEC) {
            break
        }
        put $dec
    }
    rm $unicodedata[name]
    file:close $unicodedata
}

fn create-map {|list|
    var map = [&]
    for i $list {
        set map[$i] = []
    }
    put $map
}

fn find-names {|line|
    var i = [ (str:split ';' $line) ]
    var group = $i[2]
    var hexadecimal = $i[0]

    var decimal = (hex-to-dec $hexadecimal)
    #echo 'Decimal: '$decimal >&2

    if (==s $group 'Cc') {
        put $decimal
    }
}

fn map-names {
    var namealiases = (path_:temp-file)
    download 'NameAliases.txt' > $namealiases

    var control-chars = [ (ucd-find-ccs) ]

    var control-chars-map = (create-map $control-chars)

    for line [ (str:to-nonempty-lines (io:cat $namealiases[name])) ] {
        echo $line >&2
        if (or (str:has-prefix $line '#') (==s $line '')) {
            continue
        }

        var elems = [ (str:split ';' $line) ]
        var hexadecimal = $elems[0]
        var name = $elems[1]
        var group = $elems[2]
        echo $group >&2
        var decimal = (hex-to-dec $hexadecimal)

        if (>= $decimal $MAX-CHAR-DEC) {
            break
        }

        if (not (has-value ['control' 'abbreviation' ] $group)) {
            continue
        }

        echo $decimal >&2
        if (has-value $control-chars $hexadecimal) {
            var previous = $control-chars-map[$hexadecimal]
            set control-chars-map[$hexadecimal] = [ $@previous $name ]
        }
    }

    put $control-chars-map
    rm $namealiases[name]
    file:close $namealiases
}

fn generate-file {
    var chars = (map-names)
    printf "# This file is auto-generated by generate-ansi.elv, DO NOT EDIT!\n\n\n" > '../ansi.elv'
    for i [ (keys $chars) ] {
        for x $chars[$i][1..] {
            # Drop secondary names
            if (or (str:has $x ' ') (str:has $x '-')) {
                continue
            }
            printf "# %s\nvar %s = \"\\u%s\"\n" $chars[$i][0] $x $i >> '../ansi.elv'
        }
    }
}
generate-file

