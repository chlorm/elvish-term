# Copyright (c) 2021, Cody Opel <cwopel@chlorm.net>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


use file
use path path_
use str
use github.com/chlorm/elvish-stl/io
use github.com/chlorm/elvish-stl/path


fn download [file]{
    var UCD-VERSION = '14.0.0'
    e:curl '-sL' 'https://www.unicode.org/Public/'$UCD-VERSION'/ucd/'$file
}

var MAX-CHAR-DEC = 159

fn hex-to-dec [hex]{
    base 10 '0x'$hex
}

fn ucd-control-dec [line]{
    var i = [ (str:split ';' $line) ]
    var group = $i[2]
    var hexadecimal = $i[0]

    var decimal = (hex-to-dec $hexadecimal)

    if (==s $group 'Cc') {
        put $decimal
    } else {
        put $nil
    }
}

fn ucd-find-ccs {
    var unicodedata = (path_:temp-file)
    download 'UnicodeData.txt' > $unicodedata
    var ucd = [ (io:cat $unicodedata[name]) ]
    for i $ucd {
        var dec = (ucd-control-dec $i)
        if (eq $dec $nil) {
            continue
        }
        if (>= $dec $MAX-CHAR-DEC) {
            break
        }
        put $dec
    }
    rm $unicodedata[name]
    file:close $unicodedata
}

fn create-map [list]{
    var map = [&]
    for i $list {
        set map[$i] = []
    }
    put $map
}

fn find-names [line]{
    var i = [ (str:split ';' $line) ]
    var group = $i[2]
    var hexadecimal = $i[0]

    var decimal = (hex-to-dec $hexadecimal)
    #echo 'Decimal: '$decimal >&2

    if (==s $group 'Cc') {
        put $decimal
    }
}

fn map-names {
    var namealiases = (path_:temp-file)
    download 'NameAliases.txt' > $namealiases

    var control-chars = [ (ucd-find-ccs) ]

    var control-chars-map = (create-map $control-chars)

    for line [ (io:cat $namealiases[name]) ] {
        echo $line >&2
        if (or (str:has-prefix $line '#') (==s $line '')) {
            continue
        }

        var elems = [ (str:split ';' $line) ]
        var hexadecimal = $elems[0]
        var name = $elems[1]
        var group = $elems[2]
        echo $group >&2
        var decimal = (hex-to-dec $hexadecimal)

        if (>= $decimal $MAX-CHAR-DEC) {
            break
        }

        if (not (has-value ['control' 'abbreviation' ] $group)) {
            continue
        }

        echo $decimal >&2
        if (has-value $control-chars $decimal) {
            var previous = $control-chars-map[$decimal]
            set control-chars-map[$decimal] = [ $@previous $name ]
        }
    }

    put $control-chars-map
    rm $namealiases[name]
    file:close $namealiases
}

fn generate-file {
    var chars = (map-names)
    printf "# This file is auto-generated by generate-ansi.elv, DO NOT EDIT!\n\n\n" > '../ansi.elv'
    for i [ (keys $chars) ] {
        for x $chars[$i][1..] {
            var char = (base 16 $i)
            if (< (count $char) 2) {
                set char = '0'$char
            }
            # Drop secondary names
            if (or (str:contains $x ' ') (str:contains $x '-')) {
                continue
            }
            printf "# %s\nvar %s = \"\\x%s\"\n" $chars[$i][0] $x $char >> '../ansi.elv'
        }
    }
}
generate-file

